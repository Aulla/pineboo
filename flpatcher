#!/bin/bash
APP_DIR=$(dirname $(realpath $0))


SRC_PROJECT=""
SRC_START_COMMIT=""
SRC_END_COMMIT="HEAD"
DST_PROJECT=$(pwd)
DST_APPLY_COMMIT="HEAD"

show_help() {
    echo "  $(basename $0) [options]"
    echo
    echo " -- options --"
    echo 
    echo " --src="
    echo " --dst="
    echo " --start="
    echo " --end="
    echo " --apply="
    echo " --help      -- shows this help message"
    echo
    
}


process_argument() {
    local argname="$1"
    local value="$2"
    
    case $argname in
    src) SRC_PROJECT="$value" ;;
    dst) DST_PROJECT="$value" ;;
    start) SRC_START_COMMIT="$value" ;;
    end) SRC_END_COMMIT="$value" ;;
    apply) DST_APPLY_COMMIT="$value" ;;
    help) show_help; exit 0;;
    *) echo "Unexpected argument '$argname'"; return 1 ;;
    esac
    
    #echo "* $argname -> '$value'"
    return 0
}

let n=0

ARGS=()

for arg in "$@"; do
    let n+=1
    if [[ $arg == --* ]] ; then
        argname="${arg#--}"
        value=""
        
        if [[ $argname == *"="* ]] ; then
            value="${argname#*=}"
            argname="${argname%%=*}"
        fi
       
        process_argument "$argname" "$value" || exit 1
        
    else
        ARGS+=( "$arg" )
    fi
done 

let n=0
for arg in "${ARGS[@]}"; do
    let n+=1
    echo "Unexpected positional argument '$arg'"
    exit 1
done

is_valid_git_folder() {
    local gitfolder="$1"
    test -d "$gitfolder" || return 1
    (
        cd "$gitfolder" || exit 1
        test -d ".git" || exit 1
        local line=""
        
        while read line; do
            local status="${line%% *}"
            local filename="${line#* }"
            case $status in
            ??) continue ;;
            *) echo "Modified file in working directory '$filename' ($status)"; exit 1;;
            esac
            # echo "*$status* '$filename'"
        done < <(git status --porcelain)

    ) || return 1
    
}
is_valid_git_commit() {
    local gitfolder="$1"
    local commit="$2"
    (
        cd "$gitfolder" || exit 1
        [[ "$commit" ]] || exit 2
        git log "$commit" --pretty=oneline --abbrev-commit -1 >/dev/null 2>&1 || exit 3
    )
    return $?
}

# VALIDAR --------------
is_valid_git_folder "$SRC_PROJECT" || {
    echo "El proyecto de origen '$SRC_PROJECT' no es valido." >&2; 
    exit 1;
}

is_valid_git_folder "$DST_PROJECT" || {
    echo "El proyecto de destino '$DST_PROJECT' no es valido." >&2; 
    exit 1;
}

is_valid_git_commit "$SRC_PROJECT" "$SRC_START_COMMIT" || {
    echo "El commit inicial <$SRC_START_COMMIT> no es valido." >&2; 
    exit 1;
}
is_valid_git_commit "$SRC_PROJECT" "$SRC_END_COMMIT" || {
    echo "El commit final <$SRC_END_COMMIT> no es valido." >&2; 
    exit 1;
}
is_valid_git_commit "$DST_PROJECT" "$DST_APPLY_COMMIT" || {
    echo "El commit a aplicar <$DST_APPLY_COMMIT> no es valido." >&2; 
    exit 1;
}


# 1.- Calcular lista de ficheros que componen la diferencia en SRC

FILE_LIST=()
pushd "$SRC_PROJECT" >/dev/null
IFS=$'\t'
while read -a line; do
    FILE_LIST+=("${line[2]}")
    #echo "${line[2]}"
done < <(git diff --numstat "$SRC_START_COMMIT" "$SRC_END_COMMIT")
unset IFS


# 2.- Para cada fichero en la diferencia, extraer las versiones BASE y REMOTE
for filename in "${FILE_LIST[@]}"; do
    basename=$(basename "$filename")
    if [[ $basename =~ .+\..+ ]] ; then
        fileext=".${basename##*.}"
    else
        fileext="" 
    fi
    # Ojo! si el fichero ha sido creado, aparece en REMOTE pero NO aparece en BASE
    # Ojo^2! si el fichero ha sido borrado, aparece en BASE pero NO aparece en REMOTE
    git show "$SRC_START_COMMIT":"$filename" > "/tmp/.tmpfile" 2>/dev/null && mv /tmp/.tmpfile "$DST_PROJECT/$filename.BASE$fileext"
    git show "$SRC_END_COMMIT":"$filename"   > "/tmp/.tmpfile" 2>/dev/null && mv /tmp/.tmpfile "$DST_PROJECT/$filename.REMOTE$fileext"
done


popd  >/dev/null
# 3.- Para cada fichero en la diferencia, extraer la versión LOCAL
pushd "$DST_PROJECT" >/dev/null
for filename in "${FILE_LIST[@]}"; do
    basename=$(basename "$filename")
    if [[ $basename =~ .+\..+ ]] ; then
        fileext=".${basename##*.}"
    else
        fileext="" 
    fi

    git show "$DST_APPLY_COMMIT":"$filename" > "/tmp/.tmpfile" 2>/dev/null && mv /tmp/.tmpfile "$DST_PROJECT/$filename.LOCAL$fileext"
done


# 4.- Para cada fichero en la diferencia, ejecutar el 
#     sistema de mezcla adecuado ** segun EXTENSION**
for filename in "${FILE_LIST[@]}"; do
    basename=$(basename "$filename")
    if [[ $basename =~ .+\..+ ]] ; then
        fileext=".${basename##*.}"
    else
        fileext="" 
    fi
    
    MERGE="$filename"
    BASE="$filename.BASE$fileext" 
    LOCAL="$filename.LOCAL$fileext"
    REMOTE="$filename.REMOTE$fileext"
    
    if test \( -f "$BASE" \) -a \( -f "$LOCAL" \) -a \( -f "$REMOTE" \) ; then
    
        # MEZCLA A 3
        #echo "EXT: $fileext;"     
        case $fileext in 
        .qs) flmergetool $MERGE $BASE $LOCAL $REMOTE ;;
        .ui) cp "$LOCAL" "$MERGE"; fldesigner $BASE $REMOTE $MERGE;;
    #    mtd)
    #    xml)
    #    kut)
    #    qry)
        *)  kdiff3 --auto $BASE $LOCAL $REMOTE -o $MERGE >/dev/null 2>&1 ;;
        esac
        if [[ $? == 0 ]] ; then
            git add "$MERGE"
        else
            echo "Fallo en la mezcla"
            # aqui podemos preguntar al usuario
        fi
    elif test \( \! -f "$BASE" \) -a \( \! -f "$LOCAL" \) -a \( -f "$REMOTE" \)  ; then
        # FICHERO CREADO
        cp "$REMOTE" "$MERGE"
        git add "$MERGE"
    elif test \( -f "$BASE" \) -a \( -f "$LOCAL" \) -a \( \! -f "$REMOTE" \)  ; then
        # FICHERO BORRADO
        git rm "$MERGE"
    elif test \( -f "$BASE" \) -a \( \! -f "$LOCAL" \) -a \( \! -f "$REMOTE" \)  ; then
        # FICHERO BORRADO EN LOS DOS EXTREMOS
        rm "$BASE" "$REMOTE" # igoramos realmente el fichero.
    elif test \( \! -f "$BASE" \) -a \( -f "$LOCAL" \) -a \( -f "$REMOTE" \)  ; then
        # CREACION SIMULTANEA
        echo "El fichero $MERGE ha sido creado simultaneamente en ambos proyectos"
        echo "(para recordar esta respuesta las proximas veces escriba: m* l* r*)"
        question="Elija una opcion [(m)erge|(l)ocal|(r)emoto]: "
        read -p "$question" answer 
        type="${answer:0:1}"
        remember=0
        [[ ${answer:1:1} == "*" ]] && remember=1
        
        case "${type}" in
        m) kdiff3 $LOCAL $REMOTE -o $MERGE >/dev/null 2>&1  ;;
        l) cp $LOCAL $MERGE ;;
        r) cp $REMOTE $MERGE ;;
        *) echo "Unexpected type"; [[ "" ]] ;;
        esac
        if [[ $? == 0 ]] ; then
            git add "$MERGE"
        else
            echo "Fallo en la mezcla"
            # aqui podemos preguntar al usuario
        fi
        
    elif test \( -f "$BASE" \) -a \( \! -f "$LOCAL" \) -a \( -f "$REMOTE" \)  ; then
        # BORRADO LOCAL
        echo "El fichero $MERGE no existe en este proyecto pero si fue modificado en el parche"
        echo "(para recordar esta respuesta las proximas veces escriba: b* i*)"
        $question="Elija una opcion [(b)orrar|(i)ncluir]: "
        read -p "$question" answer 
        type="${answer:0:1}"
        remember=0
        [[ ${answer:1:1} == "*" ]] && remember=1
        
        case "${type}" in
        b) rm "$BASE" "$REMOTE" && git rm "$MERGE" ;;
        i) cp "$REMOTE" "$MERGE" && git add "$MERGE";;
        *) echo "Unexpected type" ;;
        esac
        
    else
        echo "Ha ocurrido algun error anteriormente"
    fi
done


# 5.- Para cada mezcla finalizada, añadirla al proyecto DST (git add)



# 6.- Si todos los ficheros se mezclaron sin error:
#     hacer un commit, proponer un mensaje de commit.

popd >/dev/null













